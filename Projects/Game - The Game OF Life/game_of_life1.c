#include <ncurses.h>
#include <stdio.h>

int load_file(const char* name, int field[25][80]) { //загружает карту уровня из текстового файла и превращает её в цифровую матрицу (двумерный массив), которую понимает программа.
    //const char* name — путь к файлу (например, "pattern.txt").
    //int field[25][80] — массив для хранения состояния клеток (25 строк, 80 столбцов).
    FILE* f = fopen(name, "r"); 
    //fopen() — стандартная функция C для открытия файла.
    //"r" — режим чтения (read).
    //FILE — это специальный тип данных в языке C для работы с файлами (определён в stdio.h)
    //fopen = открыть файл (ключ: "r" — read).
    //f — это ваш "пульт управления" файлом.
    int i, j, c;
    if (!f) { 
        return 0;   
    }
    ////if (f) → "Если файл открыт". if (!f) → "Если файл не открыт".
    //Инициализация поля нулями Чтобы избежать "мусора" в памяти.
    for (i = 0; i < 25; i++) {
        for (j = 0; j < 80; j++) {
            field[i][j] = 0;
        }
    }

    for (i = 0; i < 25; i++) { //Внешний цикл (i) проходит по строкам поля (от 0 до 24)
        for (j = 0; j < 80; j++) { //Внутренний цикл (j) проходит по столбцам (от 0 до 79)
            c = fgetc(f); //Читает 1 символ (букву, цифру, пробел и т.д.) из файла. Служебные символы (включая '\n' — перенос строки)
            //Код читает файл символ за символом, чтобы точно определить:
            //Где расположены живые клетки ('*' → 1).
            //Где мёртвые (все остальные символы → 0).
            //Игнорировать переносы строк (\n).                
            if (c == EOF) { // это проверка на конец файла (End Of File), которая предотвращает чтение за пределами файла.
                break;
            }
            //Специальная константа (обычно -1), определённая в <stdio.h> Сигнализирует, что достигнут конец файла
            if (c == '*') { //Если текущий символ '*', программа помечает клетку как живую.
                field[i][j] = 1;
            } else if (c == '\n') { //Обрабатывает перенос строки, корректируя позицию в матрице.
                j--; //j-- нужно для корректного позиционирования при переходе на новую строку в файле
            }
        }
        while ((c = fgetc(f)) != '\n' && c != EOF) {
        }
        //Этот цикл — как "мусоропровод" для лишних символов. Если строка в файле длиннее 80 символов, он "проглатывает" всё, что не влезло, пока не найдёт конец строки (\n) или конец файла.
        //Читай символы один за другим, пока не встретишь конец строки или конец файла, и ничего с ними не делай
    }
    fclose(f); //fclose(f) — Закрытие файла, Разрывает связь между программой и файлом
    return 1;//Успешное завершение, Функция сообщает: "Файл загружен успешно"
}


//Полная хронология:
//Очистка экрана → 2. Рисование живых клеток → 3. Вывод статуса → 4. Показ на экране.
void draw(const int field[25][80], int speed) { //Игровое поле, 
    //это визуализатор игрового поля в терминале
    //Игровое поле (матрицу 25x80)
    //Панель управления (скорость и подсказки)
    int i, j; //используются как счётчики в циклах для перебора клеток игрового поля. 
    //i — счётчик для строк поля (от 0 до 24)
    //j — счётчик для столбцов поля (от 0 до 79)
    clear(); //Функция clear() в библиотеке ncurses полностью очищает экран терминала перед новой отрисовкой
    for (i = 0; i < 25; i++) {// Цикл по строкам (Y-координата)
        for (j = 0; j < 80; j++) { // Цикл по столбцам (X-координата)
            if (field[i][j]) {
                mvprintw(i, j, "*");
                //Это функция из библиотеки ncurses, которая:
                //Ставит курсор на позицию (i, j) на экране.    
                //Печатает символ * в этой позиции.
            }
        }
    }
    mvprintw(25 + 1, 0, "Speed: %d | A/Z - speed, Space - exit", speed);
    //Это статусная строка, которая показывает: Текущую скорость. Подсказку по управлению (клавиши A/Z и пробел).
    refresh(); //Обновляет экран, выводя все изменения, сделанные функциями mvprintw(), clear() и др. это функция библиотеки ncurses
    //Это команда, которая показывает всё, что ты «нарисовал» в памяти, на реальном экране. Без неё все изменения останутся невидимыми!
    //Если выводить каждый символ сразу (как printf), экран будет дёргаться. refresh() выводит всё одним мгновенным обновлением. 
    //clear() — стирает буфер (готовит чистый лист).
    //refresh() — показывает готовый рисунок.
}

int count_neighbors(const int field[25][80], int r, int c) {
    //Координаты клетки, для которой считаем соседей:
    //r — номер строки (от 0 до 24)
    //c — номер столбца (от 0 до 79)
    int count = 0, i, j; //Счётчик живых соседей вокруг клетки, Счётчик для перемещения по строкам (вертикальное смещение: -1, 0, +1), 	Счётчик для перемещения по столбцам (горизонтальное смещение: -1, 0, +1)	
    for (i = -1; i <= 1; i++) {
        for (j = -1; j <= 1; j++) {
            if (i != 0 || j != 0) { //// Если это НЕ центральная клетка
                count += field[(r + i + 25) % 25][(c + j + 80) % 80]; //field[строка][столбец] возвращает значение клетки (0 или 1)
            }
        }
    }
    return count;
    //Внешний цикл (i):
    //i = -1: Проверяем соседей выше текущей клетки.
    //i = 0: Проверяем соседей на том же уровне.
    //i = 1: Проверяем соседей ниже.
    //Внутренний цикл (j):
    //Для каждого i перебираем смещения по горизонтали:
    //j = -1: Сосед слева.
    //j = 0: Сосед по центру (сама клетка).
    //j = 1: Сосед справа.
}

void update_field(int field[25][80], int new_field[25][80]) {
    //int[25][80]	Текущее состояние игрового поля (перед обновлением)
    //int[25][80]	Пустой массив, куда запишется новое состояние поля после правил
    int i, j, n; //i и j — счётчики циклов, n — количество живых соседей
    for (i = 0; i < 25; i++) {
        for (j = 0; j < 80; j++) {
            n = count_neighbors(field, i, j); //Вычисляем количество живых соседей вокруг клетки (i,j)
            if (field[i][j] == 1) { //Правила для ЖИВОЙ клетки (1)
                if (n == 2 || n == 3) { //// Остаётся живой
                    new_field[i][j] = 1;
                } else {
                    new_field[i][j] = 0;// Умирает
                }
            } else {//Правила для МЁРТВОЙ клетки (0)
                if (n == 3) {
                    new_field[i][j] = 1; //// Оживает
                } else {
                    new_field[i][j] = 0; // Остаётся мёртвой
                }
            }
        }
    }

    for (i = 0; i < 25; i++) {
        for (j = 0; j < 80; j++) {
            field[i][j] = new_field[i][j];
        }
    }
    //Шаг 1: Читаем данные только из field (старое состояние).
    //Шаг 2: Все новые состояния пишем только в new_field.
    //Шаг 3: Когда все клетки обработаны — копируем new_field → field.
}

int get_delay(int speed) { //преобразует уровень скорости (speed) в конкретную временную задержку (в миллисекундах) для управления скоростью игры.
    const int delays[10] = {2000, 1500, 1000, 750, 500, 350, 250, 150, 100, 50};
    return delays[speed - 1]; //Индексы массива начинаются с 0, поэтому speed - 1.
}

int check_input(int* speed) { //Принимает: указатель на переменную скорости (чтобы можно было её изменять)
    int key = getch();
    //getch() читает символ с клавиатуры без ожидания Enter
    //Возвращает ASCII-код нажатой клавиши
    if (key == ' ') {
        return 0; //Если нажат пробел - функция возвращает 0, что в основном цикле игры приведёт к её завершению
    }
    if ((key == 'A' || key == 'a') && *speed < 10) {
        *speed = *speed + 1;
    }
    if ((key == 'Z' || key == 'z') && *speed > 1) {
        *speed = *speed - 1;
    }
    return 1;
    //Указатели в функции check_input используются для изменения переменной скорости напрямую, а не её копии.
}

int main(int argc, char* argv[]) { //argc = Число переданных аргументов, argv[] (argument vector) = Массив строк-аргументов
    //argv[0]: имя программы (например, "./life")
    //argv[1]: первый аргумент ("pattern.txt")
    //argv[2]: второй аргумент (если есть)
    int field[25][80], new_field[25][80]; //Игровые поля (текущее и новое состояние)
    int speed = 3; //ачальная скорость (1-10)
    int running = 1; //Флаг работы программы (1 - работает, 0 - выход)
    int i; //Счётчик для задержки 

    if (argc != 2) {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }

    if (load_file(argv[1], field) == 0) {
        printf("Error loading file\n");
        return 1;
    }
    //load_file возвращает:
    //1 (true) — если файл успешно загружен.
    //0 (false) — если произошла ошибка (файл не найден/не читается).

    initscr(); //это фундамент, без которого ncurses-программы просто не работают!
    cbreak();
    // Отключает построчную буферизацию ввода. Теперь:
    //Клавиши обрабатываются сразу после нажатия (не нужно ждать Enter).
    //Но сохраняется обработка управляющих символов (Ctrl+C и т.д.).
    noecho(); //Скрывает символы, которые вы вводите (чтобы A/Z не появлялись на экране).
    nodelay(stdscr, TRUE); //Игра не останавливается, даже если вы ничего не нажимаете (как в автоматической демо-режиме старых игр).
    curs_set(0);//Убирает мигающий _ или прямоугольник курсора с экрана.

    while (running) {
        draw(field, speed);

        if (check_input(&speed) == 0) {
            running = 0;
        } else {
            update_field(field, new_field);

            for (i = 0; i < get_delay(speed) / 10 && running; i++) {
                napms(10);
                if (check_input(&speed) == 0) {
                    running = 0;
                }
            }
        }
    }

    endwin();
    return 0;
}



//"w" — запись (создаёт новый файл или перезаписывает существующий)
//"a" — добавление в конец файла
//"rb" — чтение в бинарном режиме

//Читаем первую строку (*.*):
//i=0, j=0: '*' → field[0][0]=1
//i=0, j=1: '.' → игнорируется
//i=0, j=2: '*' → field[0][2]=1
//i=0, j=3: '\n' → игнорируется (но j уже увеличилось!)